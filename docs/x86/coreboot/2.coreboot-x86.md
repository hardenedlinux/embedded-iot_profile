# 概要

此系列文章主要分析x86架构下的coreboot，这是此系列文章的第二篇，romstage与postcar分析。此分析基于coreboot 4.6 Intel kblrvp(rvp3)主板。rvp3使用skylake平台。

# FSP简介

Intel Firmware Support Package（FSP），为Intel提供的二进制文件，提供内存和芯片组初始化的功能。FSP以特定的文件格式组织，并对外提供一些API接口。根据文件和API的差异分为不同的版本，当前有三个版本1.0、1.1、2.0。rvp3使用的FSP版本为2.0版本。以下对FSP2.0作简要介绍

## FSP二进制格式

FSP包含多个组件。组件有四种类型FSP-T、FSP-M、FSP-S和FSP-O。

- FSP-T 用在主存储器初始化之前，用于初始化零时可用的内存（如cache as ram）
- FSP-M 用于初始化主存储器，以及退出FSP-T初始化的状态
- FSP-S 用于初始化芯片组，使总线进入可枚举状态
- FSP-O OEM组件，提供OEM扩增能力

一个FSP文件中可能只有一个FSP-T/FSP-M/FSP-S组件，但可以包含多个FSP-O组件。

## FSP配置数据

FSP配置数据保存在FSP文件中。FSP配置数据被称为UDP（Updateable Product Data）。配置工具被称为BCT（Binary Configuration Tool）。配置文件被称为BSF（Boot Setting File），通常和FSP文件一起提供。

每个组件有自己的配置数据，分别被称为FSPT_UDP、FSPM_UDP、FSPS_UDP。他们具有相同的数据头。

![FSP Standard Field](https://i.imgur.com/5Z48lPG.png)

其他部分与接口功能以及具体平台相关。

## FSP输出

FSP输出为一个内存块，其中包含一个个的HOB内存块。

HOB有一个头，标记当前内存块的类型以及当前内存块的大小。其中有一个特定的HOB类型，表示此HOB为最后一个。

每一个HOB中存放的数据，与HOB类型有关。

## FSP API接口

### FSP\_TEMP\_RAM\_INIT

原型如下：

typedef EFI\_STATUS (EFIAPI \*FSP\_TEMP\_RAM\_INIT) (IN VOID\* FsptUpdDataPtr);

此接口属于FSP-T组件。用在主存储器初始化之前，用于初始化零时可用的内存（如：cache as ram）。由于在调用此过程之前，系统没有可以使用的内存，所以不能使用调用（CALL）指令，必须使用直接跳转指令执行此过程。ESP必须在跳转之前初始化返回地址，便于在过程执行结束后返回。参数为FSPT_UPD。EAX用于保存返回值，记录过程执行是否成功。[ECX,EDX]记录初始化的可用内存空间。

### FSP\_MEMORY\_INIT

原型如下：

typedef EFI\_STATUS (EFIAPI \*FSP\_MEMORY\_INIT) (IN VOID  \*FspmUpdDataPtr, OUT VOID \*\*HobListPtr);

此接口属于FSP-M组件。此函数用于初始化主存储器。参数为FSPM_UPD。返回值记录执行是否成功，并且通过指针返回一个HOB（记录资源信息）。

### FSP\_TEMP\_RAM\_EXIT

原型如下：

typedef EFI\_STATUS (EFIAPI \*FSP\_TEMP\_RAM\_EXIT) (IN VOID \*TempRamExitParamPtr);

此接口属于FSP-M组件。此函数用于退出TempRamInit初始化的临时内存。TempRamExitParamPtr在集成指南中描述，如果没有描述需要初始化为NULL。返回值记录执行是否成功。

### FSP_SILICON_INIT

原型如下：

typedef EFI\_STATUS (EFIAPI \*FSP\_SILICON\_INIT) (IN VOID\* FspsUpdDataPtr);

此接口属于FSP-S组件。此函数用于初始化芯片组。参数为FSPS_UPD。返回值记录执行是否成功。

### FSP_NOTIFY_PHASE

原型如下：

typedef EFI\_STATUS (EFIAPI \*FSP\_NOTIFY\_PHASE) (IN NOTIFY\_PHASE\_PARAMS \*NotifyPhaseParamPtr);

此接口属于FSP-S组件。此函数用于通知下一个阶段要执行的操作。NotifyPhaseParamPtr为一个结构体指针，指针中存放着枚举值。枚举值指示要执行的动作。

## FSP数据结构

FSP数据结构是跟FSP版本相关的。

在FSP2.0版本中，FSP需要UPD数据对应三个结构体（FSPT_UPD、FSPM_UPD、FSPS_UPD）。以及输出内存信息MEMORY_INFO_DATA_HOB

这部分信息位于src/vendorcode/intel/fsp/fsp2_0/skylabylake目录中

# cbmem

cbmem是一组用于内存管理的程序，他构造了一个字典，通过key可以创建、查找、删除内存。并可以用来在各个启动阶段传递数据。并构造了一个初始化机制，用来在程序启动时调用初始化函数。

## 初始化回调

cbmem定义了一个初始化函数类型，函数接受一个参数，表示机器是否是从休眠恢复。
```c
typedef void (* const cbmem_init_hook_t)(int is_recovery);
```

并且定了三个宏（ROMSTAGE\_CBMEM\_INIT\_HOOK / RAMSTAGE\_CBMEM\_INIT\_HOOK / POSTCAR\_CBMEM\_INIT\_HOOK），用于注册初始化函数。

```c
#if ENV_RAMSTAGE
    #define ROMSTAGE_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused_ = init_fn_;
    #define RAMSTAGE_CBMEM_INIT_HOOK(init_fn_) \
        static cbmem_init_hook_t init_fn_ ## _ptr_ __attribute__((used, \
        section(".rodata.cbmem_init_hooks"))) = init_fn_;
    #define POSTCAR_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused2_ = init_fn_;
#elif ENV_ROMSTAGE
    #define ROMSTAGE_CBMEM_INIT_HOOK(init_fn_) \
        static cbmem_init_hook_t init_fn_ ## _ptr_ __attribute__((used, \
        section(".rodata.cbmem_init_hooks"))) = init_fn_;
    #define RAMSTAGE_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused_ = init_fn_;
    #define POSTCAR_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused2_ = init_fn_;
#elif ENV_POSTCAR
    #define ROMSTAGE_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused2_ = init_fn_;
    #define RAMSTAGE_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused_ = init_fn_;
    #define POSTCAR_CBMEM_INIT_HOOK(init_fn_) \
        static cbmem_init_hook_t init_fn_ ## _ptr_ __attribute__((used, \
        section(".rodata.cbmem_init_hooks"))) = init_fn_;
#else
    #define ROMSTAGE_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused_ = init_fn_;
    #define RAMSTAGE_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused2_ = init_fn_;
    #define POSTCAR_CBMEM_INIT_HOOK(init_fn_) __attribute__((unused)) \
        static cbmem_init_hook_t init_fn_ ## _unused3_ = init_fn_;
#endif /* ENV_RAMSTAGE */
```

上面的宏定义了一个函数指针，把指针到的特定的段\.rodata\.cbmem\_init\_hooks，然后结合链接脚本导出的符号\_cbmem\_init\_hooks / \_ecbmem\_init\_hooks 执行对应的函数。

```c
void cbmem_run_init_hooks(int is_recovery)
{
	cbmem_init_hook_t *init_hook_ptr =
		(cbmem_init_hook_t *)&_cbmem_init_hooks;
	cbmem_init_hook_t *einit_hook_ptr =
		(cbmem_init_hook_t *)&_ecbmem_init_hooks;

	if (_cbmem_init_hooks_size == 0)
		return;

	while (init_hook_ptr !=  einit_hook_ptr) {
		(*init_hook_ptr)(is_recovery);
		init_hook_ptr++;
	}
}
```

## 内存管理

cbmem内存管理涉及很多结构体。

首先，一个内存的位置通过imdr记录。

```c
struct imdr {
	uintptr_t limit;	// 对应内存结束指针
	void *r;			// 对应内存起始指针
};
```

在这个内存块的结束位置，放置了一个数据结构imd_root_pointer

```c
struct imd_root_pointer {
	uint32_t magic;			// 标记
	int32_t root_offset;	// 记录imd_root_pointer在内存块中的偏移量
} __packed;
```

在这个内存块的开始位置，放置了一个数据结构imd_root。此数据结构记录了内存分配状况

```c
struct imd_root {
	uint32_t max_entries;		// 内存块中最多可以有多少内存分配记录
	uint32_t num_entries;		// 当前记录的内存记录数目
	uint32_t flags;				// 标记，可以对分配记录上锁
	uint32_t entry_align;		// 内存块对齐设置
	int32_t max_offset;			// 最多可用内存的偏移
	struct imd_entry entries[0];// 数组，用于记录内存分配状况
} __packed;

```

imd_root中的entries记录了内存分配状况，内存从大地址开始分配

```c
struct imd_entry {
	uint32_t magic;
	int32_t start_offset;		// 起始偏移位置
	uint32_t size;				// 内存大小
	uint32_t id;				// 用于查找内存的标示符
} __packed;
```

内存中布局情况如图![内存布局情况](https://i.imgur.com/x2yfMcY.png)



接下来简要介绍几个重要的数据结构

申请一个内存，指定id和内存大小

```c
static struct imd_entry *imd_entry_add_to_root(struct imd_root *r, uint32_t id,
						size_t size)
{
	struct imd_entry *entry;
	struct imd_entry *last_entry;
	ssize_t e_offset;
	size_t used_size;
	
  	// 当内存记录达到最大值时，内存已经被耗尽，没有空间存放内存记录
	if (r->num_entries == r->max_entries)
		return NULL;

	// 内存块的大小需要对其处理
	used_size = ALIGN_UP(size, r->entry_align);

	// 申请内存大小不能超过剩余空间
	if (used_size > imd_root_data_left(r))
		return NULL;
	
  	// 获取最后一个内存记录
  	last_entry = root_last_entry(r);
  	
  	// 计算生气到内存的偏移位置
	e_offset = last_entry->start_offset;
	e_offset -= (ssize_t)used_size;
	if (e_offset > last_entry->start_offset)
		return NULL;
	
  	// 记录新内存的信息
	entry = root_last_entry(r) + 1;
	r->num_entries++;
	imd_entry_assign(entry, id, e_offset, size);

	return entry;
}
```

查找方法

```c
static const struct imd_entry *imdr_entry_find(const struct imdr *imdr,
						uint32_t id)
{
	struct imd_root *r;
	struct imd_entry *e;
	size_t i;
	
  	// 获取内存块的起始地址
	r = imdr_root(imdr);

	if (r == NULL)
		return NULL;

	e = NULL;
	// 扫描所有的内存记录，找到id匹配的内存记录
	for (i = 1; i < r->num_entries; i++) {
		if (id != r->entries[i].id)
			continue;
		e = &r->entries[i];
		break;
	}

	return e;
}
```

删除内存块。内存块删除只支持删除最后一个内存块，代码如下

```c
int imd_entry_remove(const struct imd *imd, const struct imd_entry *entry)
{
	struct imd_root *r;
	const struct imdr *imdr;
	
  	// 确定内存块存在
	imdr = imd_entry_to_imdr(imd, entry);
	if (imdr == NULL)
		return -1;
  
	// 获取内存块记录
	r = imdr_root(imdr);
	if (r == NULL)
		return -1;
	
  	// 确定内存块信息未上锁
	if (root_is_locked(r))
		return -1;
	
  	// 确定要删除的内存块是最后一个
	if (entry != root_last_entry(r))
		return -1;
	
    //删除
	r->num_entries--;
	return 0;
}
```

cbmem是imdr的顶层结构。只是做了一些封装，这里介绍一些封装出的接口

```c
// cbmem_entry结构体就是imd_entry

// 根据id和大小申请一块内存，返回cbmem_entry
const struct cbmem_entry *cbmem_entry_add(u32 id, u64 size);

// 根据id查找一个内存块，返回cbmem_entry
const struct cbmem_entry *cbmem_entry_find(u32 id);

//删除一个内存块
int cbmem_entry_remove(const struct cbmem_entry *entry);

// 根据id和大小申请一块内存，返回申请到内存的起始地址
void *cbmem_add(u32 id, u64 size);

// 根据id查找一块内存，返回查找到内存的起始地址
void *cbmem_find(u32 id);
```

# romstage

## 入口

romstage入口位于src/arch/x86/assembly\_entry.S中。主要负责初始化堆栈，初始化SP并把堆栈空间清0。然后调用car\_stage\_entry。

初始化堆栈，通过链接脚本导出的两个符号\_car\_global\_start、\_car\_global\_end

## car\_stage\_entry

从此函数开始具体平台实现不同。在skylake下有两种实现，分别对应不同的FSP版本。我分析的rvp3主板使用FSP2.0，入口位于src/soc/intel/skylake/romstage/romstage_fsp20.c中。

```c
asmlinkage void car_stage_entry(void)
{
	bool s3wake;
	struct postcar_frame pcf;
	uintptr_t top_of_ram;
	struct chipset_power_state *ps;
	
	// 初始化串口
	console_init();
	
	// 给一些PCIe上的设备映射内存空间
	// 给一些MCH上的设备映射内存空间
	systemagent_early_init();
	
	// 通过访问硬件获取电源状态
	ps = fill_power_state();
	timestamp_add_now(TS_START_ROMSTAGE);
	s3wake = ps->prev_sleep_state == ACPI_S3;
	
	// 通过FSP接口初始化内存
	fsp_memory_init(s3wake);
	
	// 设置标志，ACPI中的标志位（与文档中描述不一致）
	pmc_set_disb();
	if (!s3wake)
		// 把FSP输出的Hob转换后保存到cbmem中
		save_dimm_info();
	
	// postcar栈空间申请，获取MTRRs的信息，这些信息保存到pcf中
	if (postcar_frame_init(&pcf, 1*KiB))
		die("Unable to initialize postcar frame.\n");
	
	// 传递一些MTRRs配置给postcar，cbmm内存
	top_of_ram = (uintptr_t) cbmem_top();
	printk(BIOS_DEBUG, "top_of_ram = 0x%lx\n", top_of_ram);
	top_of_ram -= 16*MiB;
	postcar_frame_add_mtrr(&pcf, top_of_ram, 16*MiB, MTRR_TYPE_WRBACK);
	
	// 传递一些MTRRs配置给postcar，SMM内存
	if (IS_ENABLED(CONFIG_HAVE_SMI_HANDLER)) {
		void *smm_base;
		size_t smm_size;
		uintptr_t tseg_base;

		smm_region(&smm_base, &smm_size);
		tseg_base = (uintptr_t)smm_base;
		postcar_frame_add_mtrr(&pcf, tseg_base, smm_size, MTRR_TYPE_WRBACK);
	}
	
	// 传递一些MTRRs配置给postcar，BIOS空间
	postcar_frame_add_mtrr(&pcf, 0xFFFFFFFF - CONFIG_ROM_SIZE + 1, CONFIG_ROM_SIZE, MTRR_TYPE_WRPROT);
	
	// 启动下一个阶段postcar
	run_postcar_phase(&pcf);
}
```

## systemagent\_early\_init

此函数主要用于初始化systemagent（PCIe根设备BDF编号00:00.0），在BOOTBLOCK阶段已经完成了PCIe空间内存映射（IO操作设置systemagent配置空间寄存器PCIEXBAR）

在rvp3主板上，此函数主要执行以下操作

- 给一些PCIe上的设备映射内存空间
- 给一些MCH上的设备映射内存空间
- PAM内存空间配置

为了描述外设需要映射到的内存空间，coreboot定义了一个结构体sa_mmio_descriptor

```c
/* index 为PCIe配置空间偏移量或者MMIO空间的偏移量
 * base  要映射到内存空间的起始地址
 * size  要映射到内存空间的内存大小
 * description 描述信息
 */
struct sa_mmio_descriptor {
	unsigned int index;
	uintptr_t base;
	size_t size;
	const char *description;
};
```

为了给设备映射内存空间，定义了两个函数sa\_set\_pci\_bar、sa\_set\_mch\_bar

sa\_set\_pci\_bar用于给PCIe根设备（BDF 00:00.0）上的设备映射内存空间

sa\_set\_mch\_bar用于给MCH上的设备映射内存空间

### sa\_set\_pci\_bar

```c
/*
 * fixed_set_resources为需要内存映射设备的配置信息数组
 * count 配置信息数组长度
 */

void sa_set_pci_bar(const struct sa_mmio_descriptor *fixed_set_resources, size_t count)
{
	int i;
	
  	// 遍历数组对每个设备映射内存空间
	for (i = 0; i < count; i++) {
		uintptr_t base;
		unsigned int index;

		index = fixed_set_resources[i].index;
		base = pci_read_config32(SA_DEV_ROOT, index);

		// 如果配置过则不再配置
		if (base & 0x1)
			return;
		
      	// 配置信息写入System Agent的配置空间
		base = fixed_set_resources[i].base;
		pci_write_config32(SA_DEV_ROOT, index, base | 1);
	}
}
```

### sa\_set\_mch\_bar

```c
/*
 * fixed_set_resources为需要内存映射设备的配置信息数组
 * count 配置信息数组长度
 */
void sa_set_mch_bar(const struct sa_mmio_descriptor *fixed_set_resources, size_t count)
{
	int i;
	
  	// 遍历数组对每个设备映射内存空间
	for (i = 0; i < count; i++) {
		uintptr_t base;
		unsigned int index;

		base = fixed_set_resources[i].base;
		index = fixed_set_resources[i].index;
      	
      	// 配置信息写入MCH内存映射空间
		write32((void *)(MCH_BASE_ADDRESS + index), base | 1);
	}
}

```

#### PAM内存空间配置

PAM内存空间，是内存空间的一部分，地址空间如下图

![PAM内存空间](https://i.imgur.com/3H7YG3L.png)

PAM空间的属性通过System Agent（PCIe根设备设备BDF编号为00:00.0）配置空间上的寄存器（offset 0x80-0x86）配置。

PAM0和其他PAM不同，其他PAM分为两段High/Low，PAM0只有一段，所以PAM0的配置寄存器和其他PAM配置寄存器不同

##### PAM0配置寄存器0x80

| 名字       | 位域   | 描述                                       |
| :------- | :--- | :--------------------------------------- |
| HIENABLE | 5:4  | 00 所有访问促发DMI；01只读，写触发DMI；10只写，读触发DMI；11可读写 |
| LOCK     | 0:0  | 置位后不可写改并锁定PAM所有配置                        |


#####PAM 1-6配置寄存器0x81-0x86

| 名字       | 位域   | 描述                                       |
| :------- | :--- | :--------------------------------------- |
| HIENABLE | 5:4  | 00 所有访问促发DMI；01只读，写触发DMI；10只写，读触发DMI；11可读写 |
| LOENABLE | 1:0  | 00 所有访问促发DMI；01只读，写触发DMI；10只写，读触发DMI；11可读写 |

代码如下，把所有PAM配置为内存，配置信息不上锁。

```c
void enable_pam_region(void)
{
	/* All read and writes in this region are serviced by DRAM */
	pci_write_config8(SA_DEV_ROOT, PAM0, 0x30);
	pci_write_config8(SA_DEV_ROOT, PAM1, 0x33);
	pci_write_config8(SA_DEV_ROOT, PAM2, 0x33);
	pci_write_config8(SA_DEV_ROOT, PAM3, 0x33);
	pci_write_config8(SA_DEV_ROOT, PAM4, 0x33);
	pci_write_config8(SA_DEV_ROOT, PAM5, 0x33);
	pci_write_config8(SA_DEV_ROOT, PAM6, 0x33);
}
```

## fill\_power\_state

此函数用来获取机器电源状态，通过读取PM（Power Management）外设的寄存器获取，获取到的寄存器的值保存到chipset\_power\_state中。chipset\_power\_state与具体SOC相关。

此处获取电源状态（chipset\_power\_state.prev\_sleep\_state），主要用于确认机器是否是从睡眠唤醒，如果从睡眠唤醒就不需要对保存在内存中的数据重新初始化。

## save\_dimm\_info

FSP初始化内存后，返回HOB信息。此信息需要保存并传递给后面的阶段。

此函数主要转换HOB中的内存信息并保存到cbmem中。HOB中保存的内存信息是跟FSP本版相关的，结构体类型为MEMORY\_INFO\_DATA\_HOB。cbmem中保存的内存信息是coreboot定义的memory\_info。

memory\_info是一个数组，其中的元素类型为dimm\_info。dimm\_info用于记录内存条的信息（大小、类型、频率、通道以及序列号等信息）

## 内存初始化

rvp3主板使用FSP2.0进行内存初始化。只使用到一个FSP组件，组件保存在cbfs中，名字为fspm.bin。

初始化过程就是加载fspm.bin到目标内存，并加载UDP数据，并调用。下面对一些细节进行描述。

### 防止内存重叠

因为FSP作为一个函数被调用的，函数返回后需要继续执行romstage，此处需要防止FSP覆盖romstage。此处用到数据结构memranges。

memranges用于记录内存片段，结构如下。其中free_list中存放着未使用的记录，entries存放着记录的内存信息

```c
struct memranges {
    // 内存片段记录 链表
	struct range_entry *entries;
    // 空的内存片段 链表
	struct range_entry *free_list; 
};
```

range\_entry用于记录一个内存块，可以构成链表

```c
struct range_entry {
	resource_t begin;        // 起始地址
	resource_t end;          // 结束地址
	unsigned long tag;       // 空间类型（内存、IO、MMIO...）
	struct range_entry *next;// 用于构成链表
};
```

与防止内存重叠的接口有

```c
/*
 * 初始化一个空的memranges
 * ranges   为要初始化的memranges
 * to_free  为一个range_entry的数组
 * num_free 为数组的长度
 */
void memranges_init_empty(struct memranges *ranges, struct range_entry *to_free,
			  size_t num_free)；

/*
 * 在memranges中添加一条记录
 * ranges 为要操作的memranges
 * base   添加记录的起始地址
 * size   为添加记录的空间大小
 * tag    为添加记录的空间类型
 */
void memranges_insert(struct memranges *ranges,
		      resource_t base, resource_t size, unsigned long tag)；

/*
 * 用于遍历memranges中的记录
 * ranges 为要遍历的memranges
 * r      为循环变量
 */
#define memranges_each_entry(r, ranges) \
	for (r = (ranges)->entries; r != NULL; r = r->next)
```

然后定义了一个函数用于检测空间有无重叠

```c
/*
 * 检测内存空间有无重叠
 * ranges      记录了当前程序的内存空间布局
 * description 要加载程序的名字
 * begin       要加载程序的起始地址
 * end         要加载程序的结束地址
 */
static enum cb_err check_region_overlap(const struct memranges *ranges,
					const char *description,
					uintptr_t begin, uintptr_t end)
{
	const struct range_entry *r;
	
    // 遍历记录
	memranges_each_entry(r, ranges) {
		if (end <= range_entry_base(r))  
			continue; // 加载位置在r前 无重叠检测下一个块
		if (begin >= range_entry_end(r)) 
			continue; // 加载位置在r后 无重叠检测下一个块
        // 重叠报错
		printk(BIOS_CRIT, "'%s' overlaps currently running program: "
			"[%p, %p)\n", description, (void *)begin, (void *)end);
		return CB_ERR;
	}
	// 无重叠
	return CB_SUCCESS;
}
```

检查过程如下

```c
// 用于记录当前内存信息
struct memranges memmap;

// 用于初始化，分别记录代码段数据段位置
struct range_entry freeranges[2]; 

// 初始化memmap空闲空间
memranges_init_empty(&memmap, &freeranges[0], ARRAY_SIZE(freeranges));

// 记录数据段内存空间
memranges_insert(&memmap, (uintptr_t)_car_region_start,
    	_car_relocatable_data_end - _car_region_start, 0);

// 记录代码段内存空间
memranges_insert(&memmap, (uintptr_t)_program, _program_size, 0);

// 检测内存有无重叠
if (check_region_overlap(memmap, "FSPM", fspm_begin, fspm_end) !=
		CB_SUCCESS)
		return CB_ERR;
```

### FSP加载

FSP有两种加载方式：

- 直接在BIOS内存中执行
- 加载到FSP指定的内存空间中执行

通过编译选项CONFIG\_FSP\_M\_XIP配置

直接在BIOS内存中执行，通过函数load\_fspm\_xip加载

```c
static enum cb_err load_fspm_xip(struct fsp_header *hdr,
					const struct region_device *rdev)
{
	void *base;
  
	// 从rdev获取FSP头写入hdr并矫正信息是否合法
	if (fsp_validate_component(hdr, rdev) != CB_SUCCESS)
		return CB_ERR;
	
    // 获取rdev基地址（固件地址）
	base = rdev_mmap_full(rdev);
  	
  	// 校验FSP中指定的地址和固件的地址是否一致
	if ((uintptr_t)base != hdr->image_base) {
		printk(BIOS_CRIT, "FSPM XIP base does not match: %p vs %p\n",
			(void *)(uintptr_t)hdr->image_base, base);
		return CB_ERR;
	}

	return CB_SUCCESS;
}
```

加载到FSP指定的内存中执行，通过函数load\_fspm\_mem加载

```c
static enum cb_err load_fspm_mem(struct fsp_header *hdr,
					const struct region_device *rdev,
					const struct memranges *memmap)
{
	uintptr_t fspm_begin;
	uintptr_t fspm_end;
	
  	// 从rdev获取FSP头写入hdr并矫正信息是否合法
	if (fsp_validate_component(hdr, rdev) != CB_SUCCESS)
		return CB_ERR;
	
  	// 获取FSP中指定的地址信息
	fspm_begin = hdr->image_base;
	fspm_end = fspm_begin + hdr->image_size;
	
  	// 检测FSP内存位置和romstage是否有重叠
	if (check_region_overlap(memmap, "FSPM", fspm_begin, fspm_end) !=
		CB_SUCCESS)
		return CB_ERR;

	// 把固件读取到指定位置
	if (rdev_readat(rdev, (void *)fspm_begin, 0, fspm_end - fspm_begin) < 0)
		return CB_ERR;

	return CB_SUCCESS;
}
```

### HOB信息处理

HOB为一个内存块，大小和类型由HOB头指定

```c
struct hob_header {
	uint16_t type;		// 类型，指定内存块中存放的类容
	uint16_t length;	// 内存块长度
} __packed;
```

HOB可以存放各种类型的数据，类型通过枚举定义

```c
enum hob_type {
	HOB_TYPE_HANDOFF			= 0x0001,
	HOB_TYPE_MEMORY_ALLOCATION		= 0x0002,
	HOB_TYPE_RESOURCE_DESCRIPTOR		= 0x0003,
	HOB_TYPE_GUID_EXTENSION			= 0x0004,
	HOB_TYPE_FV				= 0x0005,
	HOB_TYPE_CPU				= 0x0006,
	HOB_TYPE_MEMORY_POOL			= 0x0007,
	HOB_TYPE_FV2				= 0x0009,
	HOB_TYPE_LOAD_PEIM_UNUSED		= 0x000A,
	HOB_TYPE_UCAPSULE			= 0x000B,
	HOB_TYPE_UNUSED				= 0xFFFE,
	HOB_TYPE_END_OF_HOB_LIST		= 0xFFFF,
};
```

多个HOB内存块连续存放，最后一个HOB类型为HOB\_TYPE\_END\_OF\_HOB\_LIST标记当前HOB为最后一个。

计算下一个内存块地址，通过fsp\_next\_hob方法实现

```c
const struct hob_header *fsp_next_hob(const struct hob_header *parent)
{
	union {
		const struct hob_header *hob;
		uintptr_t addr;
	} hob_walker;

	hob_walker.hob = parent;
	hob_walker.addr += parent->length;
	return hob_walker.hob;
}
```

获取HOB内存块中的数据，通过hob\_header\_to\_struct实现

```c
static const void *hob_header_to_struct(const struct hob_header *hob)
{
	union {
		const struct hob_header *hob_hdr;
		const void *hob_descr;
		uintptr_t addr;
	} hob_walker;

	hob_walker.hob_hdr = hob;
	hob_walker.addr += HOB_HEADER_LEN;
	return hob_walker.hob_descr;
}
```

HOB中有一个类型HOB\_TYPE\_RESOURCE\_DESCRIPTOR比较常用，用于描述资源。存放的数据对应结构体hob\_resource

```c
struct hob_resource {
	uint8_t owner_guid[16];
	uint32_t type;
	uint32_t attribute_type;
	uint64_t addr;
	uint64_t length;
} __packed;
```

资源类型通过resource\_type描述

```c
enum resource_type {
	EFI_RESOURCE_SYSTEM_MEMORY		= 0,
	EFI_RESOURCE_MEMORY_MAPPED_IO		= 1,
	EFI_RESOURCE_IO				= 2,
	EFI_RESOURCE_FIRMWARE_DEVICE		= 3,
	EFI_RESOURCE_MEMORY_MAPPED_IO_PORT	= 4,
	EFI_RESOURCE_MEMORY_RESERVED		= 5,
	EFI_RESOURCE_IO_RESERVED		= 6,
	EFI_RESOURCE_MAX_MEMORY_TYPE		= 7,
};
```

HOB信息保存在一个静态变量中，并通过fsp\_get\_hob\_list\_ptr获取

```c
static void *fsp_hob_list_ptr CAR_GLOBAL;

void *fsp_get_hob_list_ptr(void)
{
	return car_get_var_ptr(&fsp_hob_list_ptr);
}
```

内存初始化修改HOB指针fsp\_hob\_list\_ptr

```c
status = fsp_raminit(&fspm_upd, fsp_get_hob_list_ptr())；
```

fsp\_hob\_list\_ptr保存了HOB信息，在save\_dimm\_info时被处理：获取内存信息保存到全局内存中cbmem

## postcar引导

postcar执行需要参数，这些参数放在堆栈上（主要是MTRR的配置）

为了引导postcar，coreboot为x86提供传参功能，实现在src/arch/x86/postcar\_loader.c

为了传递参数到堆栈，系统定义了postcar\_frame

```c
struct postcar_frame {
	uintptr_t stack;		// 堆栈指针
	uint32_t upper_mask;	// 掩码用与处理MTRR寄存器的高32位
	int max_var_MTRRs;		// 系统支持的variable MTRR寄存器数目
	int num_var_MTRRs;		// 压栈的MTRR配置数
};
```

### postcar_frame初始化

初始化分为两部分：

- 初始化postcar的堆栈空间
- 初始化MTRR相关信息

MTRR信息获取

```c
static void postcar_frame_prepare(struct postcar_frame *pcf)
{
	msr_t msr;
  	// 获取MTRR配置寄存器对数
	msr = rdmsr(MTRR_CAP_MSR);
	
    // 通过cpuid指令获取物理内存地址位数，计算获取MTRR配置高32位掩码
	pcf->upper_mask = (1 << (cpu_phys_address_size() - 32)) - 1;
	pcf->max_var_MTRRs = msr.lo & MTRR_CAP_VCNT;
	pcf->num_var_MTRRs = 0;
}
```

堆栈初始化分两种情况：cbmem动态申请，固定位置

```c
// 动态创建堆栈
int postcar_frame_init(struct postcar_frame *pcf, size_t stack_size)
{
	void *stack;

	stack = cbmem_add(CBMEM_ID_ROMSTAGE_RAM_STACK, stack_size);
	if (stack == NULL) {
		printk(BIOS_ERR, "Couldn't add %zd byte stack in cbmem.\n",
			stack_size);
		return -1;
	}

	postcar_frame_prepare(pcf);
	pcf->stack = (uintptr_t)stack;
	pcf->stack += stack_size;
	return 0;
}

// 固定位置内存
void postcar_frame_init_lowmem(struct postcar_frame *pcf)
{
	postcar_frame_prepare(pcf);
	pcf->stack = CONFIG_RAMTOP;
}
```

### 传递一组内存MTRR配置到堆栈

系统封装了一个函数postcar\_frame\_add\_mtrr用于把MTRR配置信息压到堆栈中

```c
void postcar_frame_add_mtrr(struct postcar_frame *pcf,
				uintptr_t addr, size_t size, int type)
{
  	// 一段内存可能需要使用多组MTRR进行配置
	while (size != 0) {
		uint32_t addr_lsb;
		uint32_t size_msb;
		uint32_t mtrr_size;
		
      	// 防止添加的MTRR配置数超过硬件支持的个数
		if (pcf->num_var_MTRRs >= pcf->max_var_MTRRs) {
			printk(BIOS_ERR, "No more variable MTRRs: %d\n",
					pcf->max_var_MTRRs);
			return;
		}

		addr_lsb = fls(addr);
		size_msb = fms(size);

		if (addr_lsb > size_msb)
			mtrr_size = 1 << size_msb;
		else
			mtrr_size = 1 << addr_lsb;

		printk(BIOS_DEBUG, "MTRR Range: Start=%lx End=%lx (Size %x)\n",
					addr, addr + mtrr_size, mtrr_size);
		
      	// 配置信息压栈
		stack_push(pcf, pcf->upper_mask);
		stack_push(pcf, ~(mtrr_size - 1) | MTRR_PHYS_MASK_VALID);
		stack_push(pcf, 0);
		stack_push(pcf, addr | type);
		pcf->num_var_MTRRs++;

		size -= mtrr_size;
		addr += mtrr_size;
	}
}
```

### 压入参数信息

在堆栈顶部需要压入参数个数，这个操作通过postcar\_commit\_mtrrs实现

```c
void *postcar_commit_mtrrs(struct postcar_frame *pcf)
{
	stack_push(pcf, pcf->num_var_MTRRs);
	stack_push(pcf, pcf->max_var_MTRRs);
	return (void *) pcf->stack;
}
```

# postcar

postcar主要负责撤销bootblock建立的零时内存（cache as ram），并引导下一个阶段

## 入口

postcar入口位于src/arch/x86/exit_car.S

第一步，调用chipset\_teardown\_car，此函数负责退出cache as ram状态。实现位于src/soc/intel/common/block/cpu/car/exit_car.S中。

接着通过romstage压入的信息初始化MTRRs

```assembly
	/* 清除所有的variable MTRRs. */
	pop	%ebx	/* 最后压入的是variable MTRRs的个数 */
	test	%ebx, %ebx
	jz	2f
	xor	%eax, %eax
	xor	%edx, %edx
	mov	$(MTRR_PHYS_BASE(0)), %ecx
1:
	wrmsr
	inc	%ecx
	wrmsr
	inc	%ecx
	dec	%ebx
	jnz	1b
2:

	/* 基于堆栈中的数据设置Variable MTRRs*/
	pop	%ebx	/* 从堆栈取出要设置的variable MTRRs的个数 */
	test	%ebx, %ebx
	jz	2f
	mov	$(MTRR_PHYS_BASE(0)), %ecx
1:
	/* 从堆栈取出基地址写入MSR */
	pop	%eax
	pop	%edx
	wrmsr
	inc	%ecx
	/* 从堆栈取出内存大小属性写入MSR */
	pop	%eax
	pop	%edx
	wrmsr
	inc	%ecx

	dec	%ebx
	jnz	1b
2:

	/* 使能MTRR */
	mov	$(MTRR_DEF_TYPE_MSR), %ecx
	rdmsr

```

接着调用主程序

## 程序主体

postcar主体在src/arch/x86/postcar.c中实现

```c
void main(void)
{
	/* Call TempRamExit FSP API if enabled. */
	if (IS_ENABLED(CONFIG_FSP_CAR))
		fsp_temp_ram_exit();

	console_init();

	/* Recover cbmem so infrastruture using it is functional. */
	cbmem_initialize();

	/* Display the MTRRs */
	if (IS_ENABLED(CONFIG_DISPLAY_MTRRS))
		soc_display_mtrrs();

	/* Load and run ramstage. */
	run_ramstage();
}
```

如果，之前通过FSP初始化临时内存（在主存初始化之前，通过初始化cache作为内存），需要调用fsp\_temp\_ram\_exit函数退出。

fsp\_temp\_ram\_exit中会处理fspm.bin的加载执行

接着初始化串口、cbmem并打印MTRRs，然后加载执行ramstage

# 参考

[Datasheet, Vol. 2: 7th Gen Intel® Processor Family for S Platforms and Intel® Core™ X-Series Processor Family](https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/7th-gen-core-family-desktop-s-processor-lines-datasheet-vol-2.pdf)

[Intel® Firmware Support Package: External Architecture Spec. v.1.0](https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/fsp-architecture-spec.pdf)

[Intel® Firmware Support Package: External Architecture Spec. v.1.1](https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/fsp-architecture-spec-v1-1.pdf)

[Intel® Firmware Support Package: External Architecture Spec. v.2.0](https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/fsp-architecture-spec-v2.pdf)



